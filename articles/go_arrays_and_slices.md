---
title: "Go の「配列」と「スライス」は全く別物です"
emoji: "🛰"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["Go", "golang"]
published: false
---

# はじめに
他の言語と同じように，Go言語にも「配列」という型があります
```go
// 要素数が3、中に1, 2, 3という値が入った配列
var example [3]int{1, 2, 3}

// 他の言語と同じように、インデックスを指定して取り出せる
example[0] = 1
example[2] = 3
```

しかしながら、似たような型の、**「スライス」** というものも存在します。

```go
var example []int{1, 2, 3}
```

見た目が


### スライスとは
「スライス（slice）」は、Goの中で最も利用頻度の高い型です。「可変長配列」を意味すると考えても良いです。
他の言語で言うところの、配列と非常に近い（というよりは、上位互換のようなもの）のですが、これらは明確に違うものです。なぜなら、**Goの配列型の拡張や縮小は不可能です。** 後から値を変えることができません。ここが通常の配列型とスライスの唯一無二の違いです。
ですので、Goの開発現場では、他の言語で配列を使う場面で、ほぼ必ずと言っていいほどこのスライスを使います。スライスをmakeによって生成し、後から値を操作するのです。
```go
// 変数aに配列を代入
// [5]の部分が要素数です
a := [5]int{1, 2, 2, 3, 6}

a[0] = 1
a[1] = 2
a[2] = 10000
a[6] = 8      // エラー：要素数を超過、後から追加等は一切できない。


// 変数bに、int型のスライスを定義
// スライスの中の値はintですよ〜という意味。
var b []int

// makeで生成したint型のスライス（bのものとは全く別物）を変数cに代入
// 要素数は3になる
c := make([]int, 3)

// スライスに値を追加するための専用の組み込み関数appendを使い
// 値をスライスの末尾に追加
c = append(c, 100)
```